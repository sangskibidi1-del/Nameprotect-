-- Forsaken TwoTime (Rayfield UI) by Quyendz
-- Converted from Obsidian UI to Rayfield UI, all logic preserved.

-- ===== GlideStab (Techs) =====
-- ===== GlideStab Assist (Techs) =====


-- ===== Inject Anims UI & logic (drop into the `if Library then` block, after CustomAnimLeftGroup is created) =====



-- Watcher: detect the START of the target anim (instant trigger) and run the assist once per star


-- Auto backstab (Forsaken TwoTime) - Rayfield UI version
-- Place as LocalScript (StarterGui or StarterPlayerScripts)
-- Uses Rayfield UI. Keep Rayfield at: https://sirius.menu/rayfield

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

-- CONFIG (same as original)
local DEFAULT_PROXIMITY = 8
local DEFAULT_DURATION = 0.7
local BEHIND_DISTANCE = 1.7
local CHECK_INTERVAL = 0.12
local COOLDOWN = 5
local LERP_SPEED = 0.37
local DELAY_BEFORE_STAB = 0.08
local BACKSTAB_TYPE = "lerp" -- default
-- PREDICTION CONFIG / STATE
local PREDICTION_STRENGTH = 0.6  -- 0 = no prediction, 1 = "strong" (tweak to taste)
local PREDICTION_TIME = 0.12     -- seconds to predict ahead (uses velocity * time)
-- techs config / state
local glidestabEnabled = false
local glidestabLastTime = 0
local GLIDESTAB_COOLDOWN = 3        -- 3 seconds cooldown after firing
local GLIDESTAB_BESIDE_TIMEOUT = 1  -- wait up to 1 second to become "beside" killer
local GLIDESTAB_DURATION = 0.4    -- look+dagger time
local GLIDESTAB_CHECK_RATE = 0.06
local TARGET_ANIM_ID = "89448354637442" -- animation id to watch for
-- new: aiming mode for techs ("Character" or "Camera")
local aimingMode = "Character" -- default
-- Add these vars near the other GLIDESTAB vars at top
local glidestabAssistEnabled = false
local GLIDESTAB_ASSIST_DURATION = 0.5
local GLIDESTAB_ASSIST_CHECK_RATE = 0.03
local glidestabAssistPrevPlaying = false
-- new: glide stab type for Techs ("Legit" or "Teleport")
local GLIDESTAB_TYPE = "Legit" -- "Legit" = existing behavior, "Teleport" = teleport-behind-for-duration
-- custom anims
local injectAnimsEnabled = false
local TwoTimeModulePath
pcall(function()
    TwoTimeModulePath = ReplicatedStorage:WaitForChild("Assets", 1)
        and ReplicatedStorage.Assets:FindFirstChild("Survivors")
        and ReplicatedStorage.Assets.Survivors:FindFirstChild("TwoTime")
        and ReplicatedStorage.Assets.Survivors.TwoTime:FindFirstChild("Config")
end)
local animKeys = {
    "CrouchStart",
    "CrouchIdle",
    "CrouchWalk",
    "CrouchRun",
    "Stab",
    "LungeStart",
    "LungeLoop",
    "LungeEnd",
    "Ritual",
}
-- store the user's inputs
local TwoTimeAnimInputs = {}
-- continuous tracker for killers: keeps recent pos, look and estimated velocity
local killerTrack = {}  -- keyed by HumanoidRootPart instance; values: {pos, look, vel, t, prevLook}
-- hitbox expander config
local ForsakenReachEnabled = false
local NearestDist = 120

Player.CharacterAdded:Connect(function(NewCharacter)
    Character = NewCharacter
    Humanoid = Character:WaitForChild("Humanoid")
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
end)

local RNG = Random.new()

local AttackAnimations = {
    'rbxassetid://86545133269813', --dagger
    'rbxassetid://89448354637442' -- crouch stab
}

-- Core helpers (unchanged logic)
local function getCharacter()
    return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
end

local function getDaggerButton()
    local pg = LocalPlayer:FindFirstChild("PlayerGui")
    if not pg then return nil end
    local mainUI = pg:FindFirstChild("MainUI")
    if not mainUI then return nil end
    local container = mainUI:FindFirstChild("AbilityContainer")
    if not container then return nil end
    return container:FindFirstChild("Dagger")
end

local function getDaggerCooldown()
    local btn = getDaggerButton()
    if not btn then return nil end
    local cd = btn:FindFirstChild("CooldownTime")
        or btn:FindFirstChild("Cooldown")
        or btn:FindFirstChildWhichIsA("NumberValue")
        or btn:FindFirstChildWhichIsA("StringValue")
    if cd then return cd end
    local lbl = btn:FindFirstChild("CooldownLabel") or btn:FindFirstChild("Timer") or btn:FindFirstChild("CD")
    if lbl then return lbl end
    return nil
end

local function readCooldownValue(cdObj)
    if not cdObj then return nil end
    if cdObj and cdObj:IsA("NumberValue") then
        return cdObj.Value
    end
    if cdObj and cdObj:IsA("StringValue") then
        return tonumber(cdObj.Value)
    end
    if cdObj and (cdObj:IsA("TextLabel") or cdObj:IsA("TextBox")) then
        return tonumber(cdObj.Text)
    end
    if cdObj.Value ~= nil then
        if type(cdObj.Value) == "number" then return cdObj.Value end
        if type(cdObj.Value) == "string" then return tonumber(cdObj.Value) end
    end
    if cdObj.Text ~= nil then
        return tonumber(cdObj.Text)
    end
    return nil
end

local function getKillersFolder()
    local playersFolder = Workspace:FindFirstChild("Players")
    if not playersFolder then return nil end
    return playersFolder:FindFirstChild("Killers")
end

local function isValidKillerModel(model)
    if not model then return false end
    local hrp = model:FindFirstChild("HumanoidRootPart")
    local humanoid = model:FindFirstChildWhichIsA("Humanoid")
    return hrp and humanoid and humanoid.Health and humanoid.Health > 0
end

local function tryActivateButton(btn)
    if not btn then return false end
    pcall(function()
        if btn.Activate then btn:Activate() end
    end)

    local ok, conns = pcall(function()
        if type(getconnections) == "function" and btn.MouseButton1Click then
            return getconnections(btn.MouseButton1Click)
        end
        return nil
    end)

    if ok and conns then
        for _, conn in ipairs(conns) do
            pcall(function()
                if conn.Function then
                    conn.Function()
                elseif conn.func then
                    conn.func()
                elseif conn.Fire then
                    conn.Fire()
                end
            end)
        end
    end

    pcall(function()
        if btn.Activated then
            btn.Activated:Fire()
        end
    end)

    return true
end

-- State
local enabled = false
local directbehind = false
local daggerenabled = false
local lastTrigger = 0
local rangeMode = "Around"
local aimRefCount = 0
local aimingEnabled = true
-- prediction state
local predictionEnabled = false

-- Misc state


local function setAutoRotateForCurrentCharacter(enabledValue)
    local char = LocalPlayer.Character
    if not char then return end
    local hum = char:FindFirstChildWhichIsA("Humanoid")
    if hum then
        pcall(function() hum.AutoRotate = enabledValue end)
    end
end

LocalPlayer.CharacterAdded:Connect(function(char)
    aimRefCount = 0
    local hum = char:WaitForChild("Humanoid", 5)
    if hum then pcall(function() hum.AutoRotate = true end) end
end)

-- ===================== Continuous killer tracker =====================
RunService.Heartbeat:Connect(function(dt)
    local killersFolder = getKillersFolder()
    if not killersFolder then return end
    local now = os.clock()
    for _, killer in pairs(killersFolder:GetChildren()) do
        local khrp = killer:FindFirstChild("HumanoidRootPart")
        if khrp then
            local state = killerTrack[khrp]
            local pos = khrp.Position
            local look = khrp.CFrame.LookVector
            if state and state.t and state.pos then
                local dtSample = now - state.t
                if dtSample > 0 then
                    local vel = (pos - state.pos) / dtSample
                    -- keep a smoothed velocity to reduce jitter (simple lerp smoothing)
                    local smoothVel = state.vel and (state.vel:Lerp(vel, math.clamp(dtSample*10, 0, 1))) or vel
                    killerTrack[khrp] = { pos = pos, look = look, vel = smoothVel, t = now, prevLook = state.look }
                else
                    killerTrack[khrp] = { pos = pos, look = look, vel = Vector3.new(0,0,0), t = now, prevLook = state and state.look or look }
                end
            else
                killerTrack[khrp] = { pos = pos, look = look, vel = Vector3.new(0,0,0), t = now, prevLook = look }
            end
        end
    end
end)
-- =====================================================================

-- Movement behind killer (updated to use killerTrack for prediction)
local function activateForKiller(killerModel, duration)
    if not killerModel then return end
    local char = getCharacter()
    local humanoid = char and char:FindFirstChildWhichIsA("Humanoid")
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    local khrp = killerModel and killerModel:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp or not khrp then return end

    -- Only touch AutoRotate/aim refcount when aiming is enabled.
    local didAim = false
    if aimingEnabled then
        aimRefCount = aimRefCount + 1
        didAim = true
        if aimRefCount == 1 then
            pcall(function() humanoid.AutoRotate = false end)
        end
    end

    local function finishAiming()
        if didAim then
            aimRefCount = math.max(0, aimRefCount - 1)
            if aimRefCount == 0 then
                setAutoRotateForCurrentCharacter(true)
            end
        end
    end

    -- If aiming is disabled, do nothing (no movement/rotation). Keep symmetry by scheduling cleanup.
    if not aimingEnabled then
        task.delay(duration or DEFAULT_DURATION, finishAiming)
        return
    end

    local function computeDesiredCFrame()
        local kCFrame = khrp.CFrame
        -- base behind position
        local behindPos = kCFrame.Position - (kCFrame.LookVector.Unit * BEHIND_DISTANCE)
        behindPos = Vector3.new(behindPos.X, kCFrame.Position.Y, behindPos.Z)

        -- if prediction is off, return normal CFrame
        if not predictionEnabled then
            return CFrame.new(behindPos, behindPos + kCFrame.LookVector.Unit)
        end

        -- Only make prediction adjustments for lerp/teleport
        if BACKSTAB_TYPE ~= "lerp" and BACKSTAB_TYPE ~= "teleport" then
            return CFrame.new(behindPos, behindPos + kCFrame.LookVector.Unit)
        end

        -- Use tracked velocity (smoothed) if available, otherwise fallback to instance Velocity
        local tracked = killerTrack[khrp]
        local vel = Vector3.new(0,0,0)
        if tracked and tracked.vel then
            vel = tracked.vel
        else
            pcall(function()
                vel = khrp.Velocity or Vector3.new(0,0,0)
            end)
        end
        local horizVel = Vector3.new(vel.X, 0, vel.Z) -- ignore vertical velocity

        -- predicted displacement from velocity (forward/back + lateral)
        local predictedMove = horizVel * (PREDICTION_TIME or 0.12) * (PREDICTION_STRENGTH or 0.6)

        local forward = kCFrame.LookVector
        local right = kCFrame.RightVector

        -- project predictedMove into forward and right components
        local forwardComp = forward * (predictedMove:Dot(forward))
        local lateralComp = right * (predictedMove:Dot(right))

        -- rotation change based "turn" estimation (captures turning-left/turning-right)
        local turnComp = Vector3.new(0,0,0)
        if tracked and tracked.prevLook then
            local prevLook = tracked.prevLook
            local deltaLook = forward - prevLook
            -- use projection of delta onto right vector as turning sign & magnitude
            local turnAmount = deltaLook:Dot(right)
            -- scale turning effect: multiplier tuned to be noticeable; user controls global strength
            local TURN_FACTOR = 3.0
            turnComp = right * (turnAmount * TURN_FACTOR * (PREDICTION_STRENGTH or 0.6))
        end

        -- combine offsets
        local predictedOffset = forwardComp + lateralComp + turnComp

        -- apply predicted offset to the behind position
        local finalPos = behindPos + Vector3.new(predictedOffset.X, 0, predictedOffset.Z)

        -- return CFrame facing same direction as killer
        return CFrame.new(finalPos, finalPos + kCFrame.LookVector.Unit)
    end

    if hrp.Anchored then hrp.Anchored = false end

    if BACKSTAB_TYPE == "lerp" then
        local goalCFrame = computeDesiredCFrame()
        local tweenInfo = TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local ok, tween = pcall(function() return TweenService:Create(hrp, tweenInfo, {CFrame = goalCFrame}) end)
        if ok and tween then pcall(function() tween:Play() end) else pcall(function() hrp.CFrame = goalCFrame end) end

        local t0 = os.clock()
        local conn
        conn = RunService.Heartbeat:Connect(function()
            if not conn then return end
            if os.clock() - t0 >= (duration or DEFAULT_DURATION) then
                conn:Disconnect()
                conn = nil
                finishAiming()
                return
            end
            if not khrp or not hrp then return end
            local desiredCFrame = computeDesiredCFrame()
            hrp.CFrame = hrp.CFrame:Lerp(desiredCFrame, LERP_SPEED)
        end)

    elseif BACKSTAB_TYPE == "teleport" then
        local goalCFrame = computeDesiredCFrame()
        pcall(function() hrp.CFrame = goalCFrame end)

        local t0 = os.clock()
        local conn
        conn = RunService.Heartbeat:Connect(function()
            if not conn then return end
            if os.clock() - t0 >= (duration or DEFAULT_DURATION) then
                conn:Disconnect()
                conn = nil
                finishAiming()
                return
            end
            if not khrp or not hrp then return end
            local desiredCFrame = computeDesiredCFrame()
            pcall(function() hrp.CFrame = desiredCFrame end)
        end)

    elseif BACKSTAB_TYPE == "just auto stab (if its on)" then
        local t0 = os.clock()
        local conn
        conn = RunService.Heartbeat:Connect(function()
            if not conn then return end
            if os.clock() - t0 >= (duration or DEFAULT_DURATION) then
                conn:Disconnect()
                conn = nil
                finishAiming()
                return
            end
            if not khrp or not hrp then return end
            local lookVec = khrp.CFrame.LookVector
            local curPos = hrp.Position
            local targetCFrame = CFrame.new(curPos, curPos + lookVec)
            pcall(function() hrp.CFrame = targetCFrame end)
        end)
    end
end

local function isPlayingTargetAnim(char)
    if not char then return false end
    local hum = char:FindFirstChildWhichIsA("Humanoid")
    if not hum then return false end
    local ok, tracks = pcall(function() return hum:GetPlayingAnimationTracks() end)
    if not ok or not tracks then return false end
    for _, track in ipairs(tracks) do
        local anim = track.Animation
        if anim and anim.AnimationId then
            local digits = tostring(anim.AnimationId):match("%d+")
            if digits and tostring(digits) == tostring(TARGET_ANIM_ID) then
                return true
            end
        end
    end
    return false
end

-- "Beside" test: within range and roughly to the side of the killer (using right vector dot)
local function isBesideKiller(hrp, khrp, range)
    if not hrp or not khrp then return false end
    local rel = hrp.Position - khrp.Position
    local dist = Vector3.new(rel.X, 0, rel.Z).Magnitude
    if dist > range then return false end
    if rel.Magnitude <= 0 then return false end
    local unitRel = rel.Unit
    local sideDot = math.abs(unitRel:Dot(khrp.CFrame.RightVector))
    -- threshold tuned so player must be roughly to side; adjust (0.6) if needed
    return sideDot >= 0.9
end


-- Helper: pick a candidate killer for the assist (prefer one you're already to the side of)
local function findCandidateKillerForAssist(killersFolder, hrp, range)
    if not killersFolder or not hrp then return nil end
    local nearest, nearestDist = nil, math.huge
    for _, k in pairs(killersFolder:GetChildren()) do
        if isValidKillerModel(k) then
            local khrp = k:FindFirstChild("HumanoidRootPart")
            if khrp then
                local dist = (khrp.Position - hrp.Position).Magnitude
                if dist <= range then
                    if isBesideKiller(hrp, khrp, range) then
                        -- prefer someone you're already at the side of
                        return k
                    end
                    if dist < nearestDist then
                        nearest = k
                        nearestDist = dist
                    end
                end
            end
        end
    end
    return nearest
end

-- Core assist action: look at the *side* of the killer for the configured duration
local function doGlidestabAssist(killerModel)
    if not killerModel then return end
    local char = getCharacter()
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    local humanoid = char and char:FindFirstChildWhichIsA("Humanoid")
    local khrp = killerModel and killerModel:FindFirstChild("HumanoidRootPart")
    if not hrp or not humanoid or not khrp then return end

    local SIDE_LOOK_DIST = 6
    local useMode = (typeof(aimingMode) == "string" and aimingMode) or "Character"
    local cam = workspace.CurrentCamera
    local prevCamCFrame = nil
    if useMode == "Camera" and cam then
        prevCamCFrame = cam.CFrame
    end

    -- manage AutoRotate / aim refcount only when rotating the character
    local didAim = false
    if aimingEnabled and useMode == "Character" then
        aimRefCount = aimRefCount + 1
        didAim = true
        if aimRefCount == 1 then
            pcall(function() humanoid.AutoRotate = false end)
        end
    end

    local function restoreAndReturn()
        if didAim then
            aimRefCount = math.max(0, aimRefCount - 1)
            if aimRefCount == 0 then
                setAutoRotateForCurrentCharacter(true)
            end
        end
        if useMode == "Camera" and prevCamCFrame and workspace.CurrentCamera then
            pcall(function() workspace.CurrentCamera.CFrame = prevCamCFrame end)
        end
        return
    end

    -- if already beside before starting, restore and stop immediately
    if isBesideKiller(hrp, khrp, DEFAULT_PROXIMITY) then
        restoreAndReturn()
        return
    end

    local t0 = os.clock()
    local duration = GLIDESTAB_ASSIST_DURATION or 0.5
    local tickRate = GLIDESTAB_ASSIST_CHECK_RATE or 0.03

    while os.clock() - t0 < duration do
        if not hrp or not khrp then break end

        -- STOP IMMEDIATELY if we become beside the killer
        if isBesideKiller(hrp, khrp, DEFAULT_PROXIMITY) then
            restoreAndReturn()
            return
        end

        -- Recompute which side we're on relative to the killer every tick
        local rel = hrp.Position - khrp.Position
        local sideDot = rel:Dot(khrp.CFrame.RightVector)
        local sideSign = (sideDot >= 0) and 1 or -1

        -- prediction attempt (best-effort)
        local predictedPos = khrp.Position
        local tracked = killerTrack[khrp]
        if tracked and tracked.vel then
            local horizVel = Vector3.new(tracked.vel.X, 0, tracked.vel.Z)
            predictedPos = predictedPos + horizVel * (PREDICTION_TIME or 0.12) * (PREDICTION_STRENGTH or 0.6)
        end

        -- recompute side point each tick
        local sidePoint = predictedPos + (khrp.CFrame.RightVector * SIDE_LOOK_DIST * sideSign)
        local lookAt = (useMode == "Camera" and cam) or hrp
        if lookAt then
            if useMode == "Character" then
                pcall(function()
                    hrp.CFrame = CFrame.new(hrp.Position, Vector3.new(sidePoint.X, hrp.Position.Y, sidePoint.Z))
                end)
            elseif useMode == "Camera" and cam then
                pcall(function()
                    cam.CFrame = CFrame.new(cam.CFrame.Position, Vector3.new(sidePoint.X, cam.CFrame.Position.Y, sidePoint.Z))
                end)
            end
        end
        task.wait(tickRate)
    end
    restoreAndReturn()
end

-- watch for target anim (assist auto trigger)
RunService.Heartbeat:Connect(function()
    if not glidestabAssistEnabled then return end
    local killersFolder = getKillersFolder()
    if not killersFolder then return end
    for _, killer in pairs(killersFolder:GetChildren()) do
        if isValidKillerModel(killer) and isPlayingTargetAnim(killer) then
            if not glidestabAssistPrevPlaying then
                glidestabAssistPrevPlaying = true
                task.spawn(function()
                    doGlidestabAssist(killer)
                end)
            end
            return
        end
    end
    glidestabAssistPrevPlaying = false
end)

-- ========================= UI Rayfield ==============================

local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

local Window = Rayfield:CreateWindow({
    Name = "Forsaken | Two Time",
    LoadingTitle = "Loading Forsaken...",
    LoadingSubtitle = "Made by Quyendz",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "ForsakenTwoTime",
        FileName = "Forsaken_Config"
    },
    KeySystem = false
})

-- Tabs
local mainTab = Window:CreateTab("Main", 4483362458)
local predictionTab = Window:CreateTab("Prediction", 4483362458)
local techsTab = Window:CreateTab("Techs", 4483362458)
local animTab = Window:CreateTab("Custom Anim", 4483362458)
local miscTab = Window:CreateTab("Misc", 4483362458)
local settingsTab = Window:CreateTab("Settings", 4483362458)

-- Main Tab
mainTab:CreateToggle({
    Name = "Auto Backstab",
    CurrentValue = false,
    Callback = function(v)
        enabled = v
        Rayfield:Notify({Title="Forsaken", Content="Auto Backstab: "..tostring(v), Duration=2})
    end
})
mainTab:CreateDropdown({
    Name = "Backstab Type",
    Options = {"lerp","teleport","just auto stab (if its on)"},
    CurrentOption = {"lerp"},
    Callback = function(opt)
        BACKSTAB_TYPE = opt[1]
    end
})
mainTab:CreateSlider({
    Name = "Check Interval (sec)",
    Range = {0.05,0.3},
    Increment = 0.01,
    CurrentValue = CHECK_INTERVAL,
    Callback = function(val) CHECK_INTERVAL = val end
})
mainTab:CreateButton({
    Name = "Force Stab Now",
    Callback = function()
        local btn = getDaggerButton()
        if btn then tryActivateButton(btn) end
    end
})

-- Prediction Tab
predictionTab:CreateToggle({
    Name = "Enable Prediction",
    CurrentValue = false,
    Callback = function(v)
        predictionEnabled = v
    end
})
predictionTab:CreateSlider({
    Name = "Prediction Strength",
    Range = {0,1},
    Increment = 0.05,
    CurrentValue = PREDICTION_STRENGTH,
    Callback = function(v)
        PREDICTION_STRENGTH = v
    end
})
predictionTab:CreateSlider({
    Name = "Prediction Time",
    Range = {0.05,0.25},
    Increment = 0.01,
    CurrentValue = PREDICTION_TIME,
    Callback = function(v)
        PREDICTION_TIME = v
    end
})

-- Techs Tab
techsTab:CreateToggle({
    Name = "Enable GlideStab",
    CurrentValue = false,
    Callback = function(v)
        glidestabEnabled = v
    end
})
techsTab:CreateToggle({
    Name = "Enable GlideStab Assist",
    CurrentValue = false,
    Callback = function(v)
        glidestabAssistEnabled = v
    end
})
techsTab:CreateDropdown({
    Name = "GlideStab Type",
    Options = {"Legit","Teleport"},
    CurrentOption = {"Legit"},
    Callback = function(opt)
        GLIDESTAB_TYPE = opt[1]
    end
})
techsTab:CreateDropdown({
    Name = "Aiming Mode",
    Options = {"Character","Camera"},
    CurrentOption = {"Character"},
    Callback = function(opt)
        aimingMode = opt[1]
    end
})

-- Custom Anim Tab
animTab:CreateToggle({
    Name = "Inject Custom Animations",
    CurrentValue = false,
    Callback = function(v)
        injectAnimsEnabled = v
        Rayfield:Notify({
            Title="Custom Anim",
            Content="Injection "..(v and "enabled" or "disabled"),
            Duration=2
        })
    end
})

-- Misc Tab
miscTab:CreateToggle({
    Name = "Hitbox Expander",
    CurrentValue = false,
    Callback = function(v)
        ForsakenReachEnabled = v
    end
})
miscTab:CreateSlider({
    Name = "Reach Distance",
    Range = {10,200},
    Increment = 1,
    CurrentValue = NearestDist,
    Callback = function(v)
        NearestDist = v
    end
})

-- Settings Tab
settingsTab:CreateButton({
    Name = "Reset Config",
    Callback = function()
        Rayfield:Destroy()
        Rayfield:Notify({Title="Config", Content="UI Reset - Rejoin to reload.", Duration=2})
    end
})

Rayfield:LoadConfiguration()
